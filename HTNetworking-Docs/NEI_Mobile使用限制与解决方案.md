# HTHTTP使用自动生成代码的相关问题

## 作用与优势
1. 减少了手写代码; 减少客户端人员的工作；
2. 自动生成代码格式统一、固定集中；与NEI直接对应，便于查找比对，即使实际调用的地方散落在各处，也不影响对于请求和Model的描述；
3. 网络请求的描述与网络请求的使用完全独立；
4. 自动更新为NEI对应的描述，避免因为Key不对应导致的bug; 客户端对于请求和结果的描述与服务器端严格统一；
5. 自动转为Model, 避免引入新的JSON解析库以及在解析过程中key不匹配导致的bug;

## 学习成本与使用成本
1. nei工具的使用; (成本非常低，学会安装和输入命令行即可);  
2. NEI接口定义必须按照既定的规则; 包括:
   * 参数与属性命名兼顾客户端命名规则；
   * 参数与属性命名避免客户端保留关键字；
   * 请求结果尽量定义为数据类型；
3. 更新Models与Requests后的错误解决与排除方法；
   * 修正编译错误
   * 错误调试相关  

## 限制与解决方法
代码自动生成的主要限制是生成的Model与Request方法不能被修改，所有的修改会被自动覆盖, 下面列出所有已知的会对Model与Request类有更改的情形以及对应解决方法。

### Models
1 增加方法  
通过Category增加方法

2 增加属性  
尽管添加了属性并不影响Model在网络层中的使用，但是这些属性只能以Category的方式增加，否则会被覆盖；
解决方案a: 在NEI的数据类型中额外添加字段；
优点：不需要在代码中添加额外的属性；
缺点：该字段的描述与网络请求无关，后续比较难维护，因为服务器并不返回相应信息；

解决方案b：通过Category额外添加字段；
优点：灵活，对原有Model无影响；
缺点：通过Category添加对原有Model的封装性是一个破坏，同时需要自己考虑Category添加的字段是否需要持久化存储；

TODO: 实际使用过程中能否避免增加Model属性呢？对Model进行重新包装的概率多大呢？
暂时建议还是通过Category的方式添加少量的属性，如果需要添加的属性过多的时候，再对Model进行重新组织，参见第4点；

3 持久化存储  
通过Category添加持久化存储的方法

4 Model的重新组织  
额外使用新的类进行包装；  
例如：
假如Model类的数据不能直接展示在界面上，那么需要额外在外部再封装一层成为一个ViewModel;
假如持久化存储的数据需要额外计算后再存储，那么也需要额外在外部再封装一层成为一个用于Store的Model;

5 NEI不能描述子类; (重要的问题，自动代码生成解决不了这个问题)
就是不能描述继承关系;(******)

### Requests
1 增加初始化方法  
需求描述：给一个Request增加带参数的初始化方法；  
解决方案：  
a 使用默认的init方法，然后通过设置属性的方式初始化Request;  
b 在Category里添加一个带参数的初始化方法;

2 请求的参数需要加密处理    
需求描述：请求的参数例如password需要加密处理;    
解决方案：    
将属性设置到request之前先进行加密处理再设置request的属性;  

3 请求的参数或者Header需要特殊处理   
需求描述：类似步骤2，可能有更特殊的处理，例如，原本手写的方式是给request添加一个NSArray的属性，在发送请求的时候需要将数组转成字符串;  
解决方案：  
将属性设置到request之前先进行处理；例如，如果参数本来是要传字符串的，那么需要在外部将数组转成字符串了再传递；

4 请求的参数或者Header名字与基类的默认属性或者系统保留关键字冲突  
需求描述：参数名为description  
解决方案：NEI定义接口的时候严格按照规则，避免iOS保留关键字作为请求参数;   
可能遇到的问题：不排除部分请求参数重名不太好规避；暂时没发现哪些请求参数一定是不可更名的；

5 添加额外的方法  
通过Category添加额外的方法即可;

### 定制Request请求

Note: 这部分是实际使用自动生成的代码过程中最容易遇到问题的地方。

request请求存在定制的需求；一方面，同一个App里面的所有请求可能需要共用同一种配置，例如，使用同样的request类型（全HTTP或者全WZP）; 另一方面，某些具体的请求可能使用不同的配置，比如，有几个请求需要使用第一种Cache策略；另外几个请求需要使用第二种Cache策略；除此以外，极端的情况下，请求可能还存在不同的基类，比如HTTP请求与WZP请求。

针对以上三方面的问题，手写Request代码可以比较灵活的解决这些问题，不同的请求可以从不同的基类派生；每个请求可以通过覆写基类的方法来提供不同的配置。

而自动生成的代码由于必须指定统一的基类，导致会出现定制难的问题；这些定制包括：  

* validResultBlock
* cache策略
* 超时时间
* freeze策略
* 请求类型

对于自定义Header、请求参数、requestUrl等可以通过NEI描述的特性的定制，不存在上述问题。

#### 解决思路：   
方案一：在HTBaseRequest中将可定制的方法全部开放成为属性;  
存在的问题：  
a HTBaseRequest维护成本增加;
b HTBaseRequest中无法配置全局的请求参数和策略；
c 额外的定制属性不便于添加；尤其是与请求本身无关而与App特性相关的，例如，所有的请求都要加上Cookie这种Header; 如果是通过HTBaseRequest的属性来设置，那么几乎所有的属性都需要在生成request之后设置一遍;
d 手写代码的时候，在请求的过程中还可以配置请求的参数，不是特别利于维护；

方案二：每个应用自己实现一个Request基类，该Request基类从HTBaseRequest派生, 通过开放的property来实现每个App的定制；
优点是灵活性更高；对于手写代码无影响；便于全局配置App,不需要每个请求都去设置一遍；  
缺点是对于自动生成的代码必须自己实现一个Request的基类;
后续考虑提供一个这样的示例类出来, 自动生成的类可以直接从该类派生；也可以仿照其自己写一个；实在不行就将这个示例类与方案一结合，该示例类实际是相当于HTBaseRequest在自动生成代码方案中的一个替代品，主要是考虑到往HTBaseRequest添加可能引入不必要的麻烦，导致手动写代码更复杂;

可以叫做`HTAutoBaseRequest`.

**不允许在自动生成的Request类及其扩展中添加额外的属性,建议是每个APP维护一个自己的请求基类，在请求基类中添加额外的属性统一处理与管理**  
如果该条在实际使用过程中大量情况下得不到满足，考虑调整request自动生成的关于参数描述的代码；

### 终极方案
所有解决上述问题有一个终极杀招：  
对于无法处理的请求，手写Model和Request类，自己维护，只要保证与自动生成的请求不存在命名冲突即可;   
优点：灵活性高;   
缺陷：存在冗余代码；手写代码需要维护;  

例如：
1. 某个请求对应两个response descriptor; (规避方法：手动添加response descriptor)

后续的改进：
在NEI上方便的标识哪些请求不会被自动生成；

## 推荐使用方法

1 一次性返回多种数据，每种数据存在问题都希望报错;
解决方法：
使用validResultBlock来控制，自己实现一个block可以控制任意状态下如何给出错误;

### 不满足的需求
以考拉为例，大致浏览了其中的网络请求代码后，如下几部分需求，单纯依靠客户端无法满足：  

1. 上传图片的请求无法自动生成: (由于NEI上也无法描述文件上传的请求，所以该需求不在我们的考虑之列)
2. 同一个请求，根据不同的Case传递不同的参数;(解决方法：服务器处理冗余参数，客户端自动传递全部有效参数)
   例如：
      
		- (void)fetchOrdersWithOrderStatus:(HTOrderFetchType)fetchType
		                           Success:(void (^)(NSArray *))success
		                           failure:(void (^)(NSError *))failure {
		    NSMutableDictionary *param = [self requestParams];
		    if (fetchType != HTOrderFetchTypeAll) {
		        [param setObject:[NSString stringWithFormat:@"%ld", fetchType] forKey:@"tradeStatus"];
		    }  
		 }   
   
3. 同一个请求，根据不同的Case， Url会有细微变化, 例如：  

    	NSString *urlString = [NSString stringWithFormat:@"user/order/%@", gorderID]; 
    	
	(解决方法：gorderID通过参数而不是url来区分)    	

## TODO

1 如果没有写请求类名，那么可以不生成对应的Request; （这个好像比较难做到, 但是可以控制部分请求不用生成，纯粹手写代码，灵活性更高）
2 NEI不能描述继承关系;      